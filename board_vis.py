
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: board_vis.ipynb

from test_players import RandomPlayer
from board_viz import *
from isolation import Board

import copy
from ipywidgets import interact, interactive, fixed, interact_manual
from ipywidgets import VBox, HBox, Label, Button, GridspecLayout
import ipywidgets as widgets

class BoardGrid():
    def __init__(self, game, move_history, timed_out, show_legal_moves=False):
        self.game = game
        self.width = self.game.width
        self.height = self.game.height
        self.move_history = move_history
        self.show_legal_moves = show_legal_moves
        self.timed_out = timed_out
        self.board_history = []
        self.new_board = self.setup_new_board()
        self.gridb = self.create_board_gridbox(self.new_board)
        self.generate_board_state_history()
        self.visualized_state = None
        self.output_section = widgets.Output(layout={'border': '1px solid black'})

    def setup_new_board(self,):
        return Board(player_1=self.game.__player_1__,
                     player_2=self.game.__player_2__,
                     width=self.width,
                     height=self.height)

    def get_viz_board_state(self, board):
        board_state = board.get_state()
        legal_moves = board.get_active_moves()
        active_player = 'q1' if board.__active_player__ is board.__player_1__ else 'q2'
        if self.show_legal_moves:
            for r,c,_ in legal_moves:
                if board_state[r][c][0] != 'Q':
                    board_state[r][c] = active_player
        return board_state

    def create_board_gridbox(self, game):
        h, w = game.height, game.width
        board_state = self.get_viz_board_state(game)

        grid_layout = GridspecLayout(n_rows=h,
                                     n_columns=w,
                                     grid_gap='2px 2px',
                                     width='480px',
                                     height='480px',
                                     justify_content='center'
                                    )
        for r in range(self.height):
            for c in range(self.width):
                cell = create_cell(board_state[r][c], grid_loc=(r,c))
                grid_layout[r,c] = cell

        return grid_layout

    def update_board_gridbox(self, move_i):
        board_vis_state, board_state = self.board_history[move_i]
        self.visualized_state = board_state
        for r in range(self.height):
            for c in range(self.width):
                new_name, new_style = get_details(board_vis_state[r][c])
                self.gridb[r,c].description = new_name
                self.gridb[r,c].style = new_style

    def equal_board_states(self, state1, state2):
        for r in range(self.height):
            for c in range(self.width):
                if state1[r][c] != state2[r][c]:
                    return False
        return True

    def generate_board_state_history(self,):
        for move_pair in self.move_history:
            for move in move_pair:
                self.new_board.__apply_move__(move)
                board_vis_state = self.get_viz_board_state(self.new_board)
                board_state = self.new_board.get_state()
                self.board_history.append((copy.deepcopy(board_vis_state), copy.deepcopy(board_state)))

        # First catch timeouts:
        if self.timed_out:
            print("The last player timed out when making their move.")
        else:
            assert self.equal_board_states(self.game.get_state(), self.new_board.get_state()), \
            "End game state based of move history is not consistent with state of the 'game' object."

    def get_board_state(self, x):
        """You can use this state to with set_state() to replicate same Board instance."""
        self.output_section.clear_output()
        with self.output_section:
            display(self.visualized_state)

    def show_board(self):
        # Show slider for move selection
        input_move_i = widgets.IntText(layout = Layout(width='auto'))
        slider_move_i = widgets.IntSlider(description=r"\(move[i]\)",
                                          min=0,
                                          max=len(self.board_history)-1,
                                          continuous_update=False,
                                          layout = Layout(width='auto')
                                         )
        mylink = widgets.link((input_move_i, 'value'), (slider_move_i, 'value'))
        slider = VBox([input_move_i,interactive(self.update_board_gridbox, move_i=slider_move_i)])

        get_state_button = Button(description='get board state')
        get_state_button.on_click(self.get_board_state)

        grid = GridspecLayout(4, 6)#, width='auto')
        #Left side
        grid[:3, :-3] = self.gridb
        grid[3, :-3] = slider
#         grid[3, 0] = create_expanded_button('1', 'warning')
#         grid[3, 1] = create_expanded_button('2', 'warning')
#         grid[4, 2] = create_expanded_button('3', 'danger')
        #Right side
        grid[:-1, -3:] = self.output_section
        grid[-1, -3:] = get_state_button
        display(grid)

# def vis_state(game, board_state=None):
#     if None: board_state = game.get_state()

# def interactive_play(game)